/*
 * PureCloud Platform API
 *
 * With the PureCloud Platform API, you can control all aspects of your PureCloud environment. With the APIs you can access the system configuration, manage conversations and more.
 *
 * The version of the OpenAPI document: v2
 * Contact: DeveloperEvangelists@genesys.com
 * Generated by: https://openapi-generator.tech
 */

/// WorkPlan : Work plan information



#[derive(Clone, Debug, PartialEq, Default, Serialize, Deserialize)]
pub struct WorkPlan {
    /// The globally unique identifier for the object.
    #[serde(rename = "id", skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    #[serde(rename = "name", skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Whether the work plan is enabled for scheduling
    #[serde(rename = "enabled", skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
    /// Whether the work plan is valid or not
    #[serde(rename = "valid", skip_serializing_if = "Option::is_none")]
    pub valid: Option<bool>,
    /// Whether the weekly paid time constraint is enabled for this work plan
    #[serde(rename = "constrainWeeklyPaidTime", skip_serializing_if = "Option::is_none")]
    pub constrain_weekly_paid_time: Option<bool>,
    /// Whether the weekly paid time constraint is flexible for this work plan
    #[serde(rename = "flexibleWeeklyPaidTime", skip_serializing_if = "Option::is_none")]
    pub flexible_weekly_paid_time: Option<bool>,
    /// Exact weekly paid time in minutes for this work plan. Used if flexibleWeeklyPaidTime == false
    #[serde(rename = "weeklyExactPaidMinutes", skip_serializing_if = "Option::is_none")]
    pub weekly_exact_paid_minutes: Option<i32>,
    /// Minimum weekly paid time in minutes for this work plan. Used if flexibleWeeklyPaidTime == true
    #[serde(rename = "weeklyMinimumPaidMinutes", skip_serializing_if = "Option::is_none")]
    pub weekly_minimum_paid_minutes: Option<i32>,
    /// Maximum weekly paid time in minutes for this work plan. Used if flexibleWeeklyPaidTime == true
    #[serde(rename = "weeklyMaximumPaidMinutes", skip_serializing_if = "Option::is_none")]
    pub weekly_maximum_paid_minutes: Option<i32>,
    /// Whether paid time granularity is constrained for this work plan
    #[serde(rename = "constrainPaidTimeGranularity", skip_serializing_if = "Option::is_none")]
    pub constrain_paid_time_granularity: Option<bool>,
    /// Granularity in minutes allowed for shift paid time in this work plan. Used if constrainPaidTimeGranularity == true
    #[serde(rename = "paidTimeGranularityMinutes", skip_serializing_if = "Option::is_none")]
    pub paid_time_granularity_minutes: Option<i32>,
    /// Whether the minimum time between shifts constraint is enabled for this work plan
    #[serde(rename = "constrainMinimumTimeBetweenShifts", skip_serializing_if = "Option::is_none")]
    pub constrain_minimum_time_between_shifts: Option<bool>,
    /// Minimum time between shifts in minutes defined in this work plan. Used if constrainMinimumTimeBetweenShifts == true
    #[serde(rename = "minimumTimeBetweenShiftsMinutes", skip_serializing_if = "Option::is_none")]
    pub minimum_time_between_shifts_minutes: Option<i32>,
    /// Maximum number days in a week allowed to be scheduled for this work plan
    #[serde(rename = "maximumDays", skip_serializing_if = "Option::is_none")]
    pub maximum_days: Option<i32>,
    /// Minimum amount of consecutive non working minutes per week that agents who are assigned this work plan are allowed to have off
    #[serde(rename = "minimumConsecutiveNonWorkingMinutesPerWeek", skip_serializing_if = "Option::is_none")]
    pub minimum_consecutive_non_working_minutes_per_week: Option<i32>,
    /// Whether to constrain the maximum consecutive working weekends
    #[serde(rename = "constrainMaximumConsecutiveWorkingWeekends", skip_serializing_if = "Option::is_none")]
    pub constrain_maximum_consecutive_working_weekends: Option<bool>,
    /// The maximum number of consecutive weekends that agents who are assigned to this work plan are allowed to work
    #[serde(rename = "maximumConsecutiveWorkingWeekends", skip_serializing_if = "Option::is_none")]
    pub maximum_consecutive_working_weekends: Option<i32>,
    /// The minimum number of days that agents assigned to a work plan must work per week
    #[serde(rename = "minimumWorkingDaysPerWeek", skip_serializing_if = "Option::is_none")]
    pub minimum_working_days_per_week: Option<i32>,
    /// Whether to constrain the maximum consecutive working days
    #[serde(rename = "constrainMaximumConsecutiveWorkingDays", skip_serializing_if = "Option::is_none")]
    pub constrain_maximum_consecutive_working_days: Option<bool>,
    /// The maximum number of consecutive days that agents assigned to this work plan are allowed to work. Used if constrainMaximumConsecutiveWorkingDays == true
    #[serde(rename = "maximumConsecutiveWorkingDays", skip_serializing_if = "Option::is_none")]
    pub maximum_consecutive_working_days: Option<i32>,
    /// The time period in minutes for the duration between the start times of two consecutive working days
    #[serde(rename = "minimumShiftStartDistanceMinutes", skip_serializing_if = "Option::is_none")]
    pub minimum_shift_start_distance_minutes: Option<i32>,
    /// Minimum days off in the planning period
    #[serde(rename = "minimumDaysOffPerPlanningPeriod", skip_serializing_if = "Option::is_none")]
    pub minimum_days_off_per_planning_period: Option<i32>,
    /// Maximum days off in the planning period
    #[serde(rename = "maximumDaysOffPerPlanningPeriod", skip_serializing_if = "Option::is_none")]
    pub maximum_days_off_per_planning_period: Option<i32>,
    /// Minimum paid minutes in the planning period
    #[serde(rename = "minimumPaidMinutesPerPlanningPeriod", skip_serializing_if = "Option::is_none")]
    pub minimum_paid_minutes_per_planning_period: Option<i32>,
    /// Maximum paid minutes in the planning period
    #[serde(rename = "maximumPaidMinutesPerPlanningPeriod", skip_serializing_if = "Option::is_none")]
    pub maximum_paid_minutes_per_planning_period: Option<i32>,
    #[serde(rename = "optionalDays", skip_serializing_if = "Option::is_none")]
    pub optional_days: Option<Box<crate::models::SetWrapperDayOfWeek>>,
    /// This constraint ensures that an agent starts each workday within a user-defined time threshold
    #[serde(rename = "shiftStartVarianceType", skip_serializing_if = "Option::is_none")]
    pub shift_start_variance_type: Option<ShiftStartVarianceType>,
    #[serde(rename = "shiftStartVariances", skip_serializing_if = "Option::is_none")]
    pub shift_start_variances: Option<Box<crate::models::ListWrapperShiftStartVariance>>,
    /// Shifts in this work plan
    #[serde(rename = "shifts", skip_serializing_if = "Option::is_none")]
    pub shifts: Option<Vec<crate::models::WorkPlanShift>>,
    /// Agents in this work plan
    #[serde(rename = "agents", skip_serializing_if = "Option::is_none")]
    pub agents: Option<Vec<crate::models::DeletableUserReference>>,
    /// Number of agents in this work plan
    #[serde(rename = "agentCount", skip_serializing_if = "Option::is_none")]
    pub agent_count: Option<i32>,
    #[serde(rename = "metadata")]
    pub metadata: Box<crate::models::WfmVersionedEntityMetadata>,
    /// The URI for this object
    #[serde(rename = "selfUri", skip_serializing_if = "Option::is_none")]
    pub self_uri: Option<String>,
}

impl WorkPlan {
    /// Work plan information
    pub fn new(metadata: crate::models::WfmVersionedEntityMetadata) -> WorkPlan {
        WorkPlan {
            id: None,
            name: None,
            enabled: None,
            valid: None,
            constrain_weekly_paid_time: None,
            flexible_weekly_paid_time: None,
            weekly_exact_paid_minutes: None,
            weekly_minimum_paid_minutes: None,
            weekly_maximum_paid_minutes: None,
            constrain_paid_time_granularity: None,
            paid_time_granularity_minutes: None,
            constrain_minimum_time_between_shifts: None,
            minimum_time_between_shifts_minutes: None,
            maximum_days: None,
            minimum_consecutive_non_working_minutes_per_week: None,
            constrain_maximum_consecutive_working_weekends: None,
            maximum_consecutive_working_weekends: None,
            minimum_working_days_per_week: None,
            constrain_maximum_consecutive_working_days: None,
            maximum_consecutive_working_days: None,
            minimum_shift_start_distance_minutes: None,
            minimum_days_off_per_planning_period: None,
            maximum_days_off_per_planning_period: None,
            minimum_paid_minutes_per_planning_period: None,
            maximum_paid_minutes_per_planning_period: None,
            optional_days: None,
            shift_start_variance_type: None,
            shift_start_variances: None,
            shifts: None,
            agents: None,
            agent_count: None,
            metadata: Box::new(metadata),
            self_uri: None,
        }
    }
}

/// This constraint ensures that an agent starts each workday within a user-defined time threshold
#[derive(Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Serialize, Deserialize)]
pub enum ShiftStartVarianceType {
    #[serde(rename = "ShiftStart")]
    ShiftStart,
    #[serde(rename = "ShiftStartAndPaidDuration")]
    ShiftStartAndPaidDuration,
}

impl Default for ShiftStartVarianceType {
    fn default() -> ShiftStartVarianceType {
        Self::ShiftStart
    }
}

