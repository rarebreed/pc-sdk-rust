/*
 * PureCloud Platform API
 *
 * With the PureCloud Platform API, you can control all aspects of your PureCloud environment. With the APIs you can access the system configuration, manage conversations and more.
 *
 * The version of the OpenAPI document: v2
 * Contact: DeveloperEvangelists@genesys.com
 * Generated by: https://openapi-generator.tech
 */




#[derive(Clone, Debug, PartialEq, Default, Serialize, Deserialize)]
pub struct ShiftTradeSettings {
    /// Whether shift trading is enabled for this management unit
    #[serde(rename = "enabled", skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
    /// Whether automatic shift trade review is enabled according to the rules defined in for this management unit
    #[serde(rename = "autoReview", skip_serializing_if = "Option::is_none")]
    pub auto_review: Option<bool>,
    /// Whether direct shift trades between agents are allowed
    #[serde(rename = "allowDirectTrades", skip_serializing_if = "Option::is_none")]
    pub allow_direct_trades: Option<bool>,
    /// The minimum number of hours in the future shift trades are allowed
    #[serde(rename = "minHoursInFuture", skip_serializing_if = "Option::is_none")]
    pub min_hours_in_future: Option<i32>,
    /// How to handle shift trades which involve unequal paid times
    #[serde(rename = "unequalPaid", skip_serializing_if = "Option::is_none")]
    pub unequal_paid: Option<UnequalPaid>,
    /// How to handle one-sided shift trades
    #[serde(rename = "oneSided", skip_serializing_if = "Option::is_none")]
    pub one_sided: Option<OneSided>,
    /// How to handle shift trades which result in violations of weekly minimum paid time constraint
    #[serde(rename = "weeklyMinPaidViolations", skip_serializing_if = "Option::is_none")]
    pub weekly_min_paid_violations: Option<WeeklyMinPaidViolations>,
    /// How to handle shift trades which result in violations of weekly maximum paid time constraint
    #[serde(rename = "weeklyMaxPaidViolations", skip_serializing_if = "Option::is_none")]
    pub weekly_max_paid_violations: Option<WeeklyMaxPaidViolations>,
    /// Whether to constrain shift trades to agents with matching queues
    #[serde(rename = "requiresMatchingQueues", skip_serializing_if = "Option::is_none")]
    pub requires_matching_queues: Option<bool>,
    /// Whether to constrain shift trades to agents with matching languages
    #[serde(rename = "requiresMatchingLanguages", skip_serializing_if = "Option::is_none")]
    pub requires_matching_languages: Option<bool>,
    /// Whether to constrain shift trades to agents with matching skills
    #[serde(rename = "requiresMatchingSkills", skip_serializing_if = "Option::is_none")]
    pub requires_matching_skills: Option<bool>,
    /// Whether to constrain shift trades to agents with matching planning groups
    #[serde(rename = "requiresMatchingPlanningGroups", skip_serializing_if = "Option::is_none")]
    pub requires_matching_planning_groups: Option<bool>,
    /// Rules that specify what to do with activity categories that are part of a shift defined in a trade
    #[serde(rename = "activityCategoryRules", skip_serializing_if = "Option::is_none")]
    pub activity_category_rules: Option<Vec<crate::models::ShiftTradeActivityRule>>,
}

impl ShiftTradeSettings {
    pub fn new() -> ShiftTradeSettings {
        ShiftTradeSettings {
            enabled: None,
            auto_review: None,
            allow_direct_trades: None,
            min_hours_in_future: None,
            unequal_paid: None,
            one_sided: None,
            weekly_min_paid_violations: None,
            weekly_max_paid_violations: None,
            requires_matching_queues: None,
            requires_matching_languages: None,
            requires_matching_skills: None,
            requires_matching_planning_groups: None,
            activity_category_rules: None,
        }
    }
}

/// How to handle shift trades which involve unequal paid times
#[derive(Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Serialize, Deserialize)]
pub enum UnequalPaid {
    #[serde(rename = "Allow")]
    Allow,
    #[serde(rename = "Disallow")]
    Disallow,
    #[serde(rename = "AdminReview")]
    AdminReview,
}

impl Default for UnequalPaid {
    fn default() -> UnequalPaid {
        Self::Allow
    }
}
/// How to handle one-sided shift trades
#[derive(Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Serialize, Deserialize)]
pub enum OneSided {
    #[serde(rename = "Allow")]
    Allow,
    #[serde(rename = "Disallow")]
    Disallow,
    #[serde(rename = "AdminReview")]
    AdminReview,
}

impl Default for OneSided {
    fn default() -> OneSided {
        Self::Allow
    }
}
/// How to handle shift trades which result in violations of weekly minimum paid time constraint
#[derive(Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Serialize, Deserialize)]
pub enum WeeklyMinPaidViolations {
    #[serde(rename = "Allow")]
    Allow,
    #[serde(rename = "Disallow")]
    Disallow,
    #[serde(rename = "AdminReview")]
    AdminReview,
}

impl Default for WeeklyMinPaidViolations {
    fn default() -> WeeklyMinPaidViolations {
        Self::Allow
    }
}
/// How to handle shift trades which result in violations of weekly maximum paid time constraint
#[derive(Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Serialize, Deserialize)]
pub enum WeeklyMaxPaidViolations {
    #[serde(rename = "Allow")]
    Allow,
    #[serde(rename = "Disallow")]
    Disallow,
    #[serde(rename = "AdminReview")]
    AdminReview,
}

impl Default for WeeklyMaxPaidViolations {
    fn default() -> WeeklyMaxPaidViolations {
        Self::Allow
    }
}

