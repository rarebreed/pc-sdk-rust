/*
 * PureCloud Platform API
 *
 * With the PureCloud Platform API, you can control all aspects of your PureCloud environment. With the APIs you can access the system configuration, manage conversations and more.
 *
 * The version of the OpenAPI document: v2
 * Contact: DeveloperEvangelists@genesys.com
 * Generated by: https://openapi-generator.tech
 */




#[derive(Clone, Debug, PartialEq, Default, Serialize, Deserialize)]
pub struct Recording {
    /// The globally unique identifier for the object.
    #[serde(rename = "id", skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    #[serde(rename = "name", skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(rename = "conversationId", skip_serializing_if = "Option::is_none")]
    pub conversation_id: Option<String>,
    #[serde(rename = "path", skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
    /// The start time of the recording. Null when there is no playable media.
    #[serde(rename = "startTime", skip_serializing_if = "Option::is_none")]
    pub start_time: Option<String>,
    /// The end time of the recording. Null when there is no playable media.
    #[serde(rename = "endTime", skip_serializing_if = "Option::is_none")]
    pub end_time: Option<String>,
    /// The type of media that the recording is. At the moment that could be audio, chat, or email.
    #[serde(rename = "media", skip_serializing_if = "Option::is_none")]
    pub media: Option<String>,
    /// Annotations that belong to the recording.
    #[serde(rename = "annotations", skip_serializing_if = "Option::is_none")]
    pub annotations: Option<Vec<crate::models::Annotation>>,
    /// Represents a chat transcript
    #[serde(rename = "transcript", skip_serializing_if = "Option::is_none")]
    pub transcript: Option<Vec<crate::models::ChatMessage>>,
    /// Represents an email transcript
    #[serde(rename = "emailTranscript", skip_serializing_if = "Option::is_none")]
    pub email_transcript: Option<Vec<crate::models::RecordingEmailMessage>>,
    /// Represents a messaging transcript
    #[serde(rename = "messagingTranscript", skip_serializing_if = "Option::is_none")]
    pub messaging_transcript: Option<Vec<crate::models::RecordingMessagingMessage>>,
    /// Represents the current file state for a recording. Examples: Uploading, Archived, etc
    #[serde(rename = "fileState", skip_serializing_if = "Option::is_none")]
    pub file_state: Option<FileState>,
    /// The amount of time a restored recording will remain restored before being archived again. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
    #[serde(rename = "restoreExpirationTime", skip_serializing_if = "Option::is_none")]
    pub restore_expiration_time: Option<String>,
    /// The different mediaUris for the recording. Null when there is no playable media.
    #[serde(rename = "mediaUris", skip_serializing_if = "Option::is_none")]
    pub media_uris: Option<::std::collections::HashMap<String, crate::models::MediaResult>>,
    #[serde(rename = "estimatedTranscodeTimeMs", skip_serializing_if = "Option::is_none")]
    pub estimated_transcode_time_ms: Option<i64>,
    #[serde(rename = "actualTranscodeTimeMs", skip_serializing_if = "Option::is_none")]
    pub actual_transcode_time_ms: Option<i64>,
    /// The date the recording will be archived. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
    #[serde(rename = "archiveDate", skip_serializing_if = "Option::is_none")]
    pub archive_date: Option<String>,
    /// The type of archive medium used. Example: CloudArchive
    #[serde(rename = "archiveMedium", skip_serializing_if = "Option::is_none")]
    pub archive_medium: Option<ArchiveMedium>,
    /// The date the recording will be deleted. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
    #[serde(rename = "deleteDate", skip_serializing_if = "Option::is_none")]
    pub delete_date: Option<String>,
    /// The date the recording will be exported. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
    #[serde(rename = "exportDate", skip_serializing_if = "Option::is_none")]
    pub export_date: Option<String>,
    /// The date the recording was exported. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
    #[serde(rename = "exportedDate", skip_serializing_if = "Option::is_none")]
    pub exported_date: Option<String>,
    /// Duration of transcoded media in milliseconds
    #[serde(rename = "outputDurationMs", skip_serializing_if = "Option::is_none")]
    pub output_duration_ms: Option<i32>,
    /// Size of transcoded media in bytes. 0 if there is no transcoded media.
    #[serde(rename = "outputSizeInBytes", skip_serializing_if = "Option::is_none")]
    pub output_size_in_bytes: Option<i32>,
    /// How many archive restorations the organization is allowed to have.
    #[serde(rename = "maxAllowedRestorationsForOrg", skip_serializing_if = "Option::is_none")]
    pub max_allowed_restorations_for_org: Option<i32>,
    /// The remaining archive restorations the organization has.
    #[serde(rename = "remainingRestorationsAllowedForOrg", skip_serializing_if = "Option::is_none")]
    pub remaining_restorations_allowed_for_org: Option<i32>,
    /// The session id represents an external resource id, such as email, call, chat, etc
    #[serde(rename = "sessionId", skip_serializing_if = "Option::is_none")]
    pub session_id: Option<String>,
    /// The users participating in the conversation
    #[serde(rename = "users", skip_serializing_if = "Option::is_none")]
    pub users: Option<Vec<crate::models::User>>,
    /// Role of the file recording. It can be either customer_experience or adhoc.
    #[serde(rename = "recordingFileRole", skip_serializing_if = "Option::is_none")]
    pub recording_file_role: Option<RecordingFileRole>,
    /// Status of a recording that cannot be returned because of an error
    #[serde(rename = "recordingErrorStatus", skip_serializing_if = "Option::is_none")]
    pub recording_error_status: Option<RecordingErrorStatus>,
    /// The start time of the full recording, before any segment access restrictions are applied. Null when there is no playable media. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
    #[serde(rename = "originalRecordingStartTime", skip_serializing_if = "Option::is_none")]
    pub original_recording_start_time: Option<String>,
    /// The URI for this object
    #[serde(rename = "selfUri", skip_serializing_if = "Option::is_none")]
    pub self_uri: Option<String>,
}

impl Recording {
    pub fn new() -> Recording {
        Recording {
            id: None,
            name: None,
            conversation_id: None,
            path: None,
            start_time: None,
            end_time: None,
            media: None,
            annotations: None,
            transcript: None,
            email_transcript: None,
            messaging_transcript: None,
            file_state: None,
            restore_expiration_time: None,
            media_uris: None,
            estimated_transcode_time_ms: None,
            actual_transcode_time_ms: None,
            archive_date: None,
            archive_medium: None,
            delete_date: None,
            export_date: None,
            exported_date: None,
            output_duration_ms: None,
            output_size_in_bytes: None,
            max_allowed_restorations_for_org: None,
            remaining_restorations_allowed_for_org: None,
            session_id: None,
            users: None,
            recording_file_role: None,
            recording_error_status: None,
            original_recording_start_time: None,
            self_uri: None,
        }
    }
}

/// Represents the current file state for a recording. Examples: Uploading, Archived, etc
#[derive(Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Serialize, Deserialize)]
pub enum FileState {
    #[serde(rename = "ARCHIVED")]
    ARCHIVED,
    #[serde(rename = "AVAILABLE")]
    AVAILABLE,
    #[serde(rename = "DELETED")]
    DELETED,
    #[serde(rename = "RESTORED")]
    RESTORED,
    #[serde(rename = "RESTORING")]
    RESTORING,
    #[serde(rename = "UPLOADING")]
    UPLOADING,
    #[serde(rename = "ERROR")]
    ERROR,
}

impl Default for FileState {
    fn default() -> FileState {
        Self::ARCHIVED
    }
}
/// The type of archive medium used. Example: CloudArchive
#[derive(Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Serialize, Deserialize)]
pub enum ArchiveMedium {
    #[serde(rename = "CLOUDARCHIVE")]
    CLOUDARCHIVE,
}

impl Default for ArchiveMedium {
    fn default() -> ArchiveMedium {
        Self::CLOUDARCHIVE
    }
}
/// Role of the file recording. It can be either customer_experience or adhoc.
#[derive(Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Serialize, Deserialize)]
pub enum RecordingFileRole {
    #[serde(rename = "CUSTOMER_EXPERIENCE")]
    CUSTOMEREXPERIENCE,
    #[serde(rename = "ADHOC")]
    ADHOC,
}

impl Default for RecordingFileRole {
    fn default() -> RecordingFileRole {
        Self::CUSTOMEREXPERIENCE
    }
}
/// Status of a recording that cannot be returned because of an error
#[derive(Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Serialize, Deserialize)]
pub enum RecordingErrorStatus {
    #[serde(rename = "EMAIL_TRANSCRIPT_TOO_LARGE")]
    EMAILTRANSCRIPTTOOLARGE,
}

impl Default for RecordingErrorStatus {
    fn default() -> RecordingErrorStatus {
        Self::EMAILTRANSCRIPTTOOLARGE
    }
}

